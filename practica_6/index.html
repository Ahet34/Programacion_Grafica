<!DOCTYPE html>
<html>
  <head>
    <title>Cubo Color Interacción (Cuaternión) en WebGL 2.0</title>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />
    <style>
      /* Estilos para que el canvas llene la pantalla */
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      #titulo {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-family: sans-serif;
        z-index: 10;
        pointer-events: none;
      }
      #webglcanvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
      #menu {
        position: absolute;
        top: 50px;
        left: 10px;
        width: 220px;
        background: rgba(255, 255, 255, 0.5);
        padding: 10px;
        z-index: 11;
        font-family: sans-serif;
        color: #000;
        border-radius: 8px;
      }
      #menu h3 {
        margin: 5px 0;
        font-size: 1em;
      }
      #menu label {
        display: block;
        margin: 6px 0 2px;
        font-size: 0.9em;
      }
      #menu input[type="number"],
      #menu input[type="range"],
      #menu input[type="color"] {
        width: 100%;
        margin-bottom: 8px;
      }
    </style>
  </head>
  <body>
    <h1 id="titulo">Muñeco de nieve</h1>
    <div id="menu">
      <h3>Controles</h3>
      <label>Color cuerpo:</label>
      <input type="color" id="bodyColor" value="#ffffff" />

      <label>Color sombrero:</label>
      <input type="color" id="hatColor" value="#000000" />

      <label>Color nariz:</label>
      <input type="color" id="noseColor" value="#ff8000" />

      <label>Rotar X:</label>
      <input type="range" id="rotX" min="0" max="360" value="0" />
      <label>Rotar Y:</label>
      <input type="range" id="rotY" min="0" max="360" value="0" />
      <label>Rotar Z:</label>
      <input type="range" id="rotZ" min="0" max="360" value="0" />

      <label
        ><input type="checkbox" id="toggleFloor" checked /> Mostrar piso</label
      >
      <label>Color piso:</label>
      <input type="color" id="floorColor" value="#000000" />
      <button id="resetBtn">Reiniciar</button>
    </div>
    <canvas id="webglcanvas" oncontextmenu="return false;"></canvas>
    <!--
        /***************************************************************************/
        /* Se definen los códigos shaders.                                         */
        /***************************************************************************/
      -->
    <script id="vs" type="vertex">
      #version 300 es
      uniform mat4 uMatrizProyeccion;
      uniform mat4 uMatrizVista;
      uniform mat4 uMatrizModelo;
      layout(location = 0) in vec3 aVertices;
      layout(location = 1) in vec4 aColores;
      out vec4 vColores;
      void main() {
        vColores = aColores;
        gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
      }
    </script>

    <script id="fs" type="fragment">
      #version 300 es
      precision highp float;
      in vec4 vColores;
      out vec4 color;
      void main() {
          color = vColores;
      }
    </script>

    <script>
      "use strict";

      /* Variables globales */
      var canvas;
      var programaID;
      var gl;
      var muñeco;
      var suelo;
      var arcBall;

      /* Variables Uniformes */
      var uMatrizProyeccion;
      var uMatrizVista;
      var uMatrizModelo;

      /* Matrices */
      var MatrizProyeccion = new Array(16);
      var MatrizVista = new Array(16);
      var MatrizModelo = new Array(16);

      /* Para la interacción */
      var tx = 0,
        ty = 0;
      var sx = 0.4,
        sy = 0.4,
        sz = 0.4;
      var MatrizRotacion = new Array(16);
      var Matriz = new Array(16);
      var boton_izq_presionado = false;
      var boton_der_presionado = false;

      /***************************************************************************/
      /* Se crean, compilan y enlazan los programas Shader                       */
      /***************************************************************************/
      let speedX = 0,
        speedY = 0,
        speedZ = 0;
      let angleX = 0,
        angleY = 0,
        angleZ = 0;

      let showFloor = true;
      let floorColorRGBA = [0, 0, 0, 1];
      function compilaEnlazaLosShaders() {
        /* Se compila el shader de vertice */
        var shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(
          shaderDeVertice,
          document.getElementById("vs").text.trim()
        );
        gl.compileShader(shaderDeVertice);
        if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shaderDeVertice));
        }

        /* Se compila el shader de fragmento */
        var shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(
          shaderDeFragmento,
          document.getElementById("fs").text.trim()
        );
        gl.compileShader(shaderDeFragmento);
        if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shaderDeFragmento));
        }

        /* Se enlaza ambos shader */
        programaID = gl.createProgram();
        gl.attachShader(programaID, shaderDeVertice);
        gl.attachShader(programaID, shaderDeFragmento);
        gl.linkProgram(programaID);
        if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(programaID));
        }

        /* Se instala el programa de shaders para utilizarlo */
        gl.useProgram(programaID);
      }

      /***************************************************************************/
      /* Transformaciones mediante matrices                                      */
      /***************************************************************************/

      /* Convierte de grados a radianes */
      function toRadians(grados) {
        return (grados * Math.PI) / 180;
      }

      /* Matriz Identidad */
      function identidad(r) {
        r[0] = 1;
        r[4] = 0;
        r[8] = 0;
        r[12] = 0;
        r[1] = 0;
        r[5] = 1;
        r[9] = 0;
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = 1;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
      }

      /* Traslación - glTranslatef */
      function traslacion(matriz, tx, ty, tz) {
        var r = new Array(16);
        r[0] = 1;
        r[4] = 0;
        r[8] = 0;
        r[12] = tx;
        r[1] = 0;
        r[5] = 1;
        r[9] = 0;
        r[13] = ty;
        r[2] = 0;
        r[6] = 0;
        r[10] = 1;
        r[14] = tz;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Escalación - glScalef */
      function escalacion(matriz, sx, sy, sz) {
        var r = new Array(16);
        r[0] = sx;
        r[4] = 0;
        r[8] = 0;
        r[12] = 0;
        r[1] = 0;
        r[5] = sy;
        r[9] = 0;
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = sz;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Rotación sobre X - glRotatef */
      function rotacionX(matriz, theta) {
        let r = new Array(16);
        var c = Math.cos(toRadians(theta));
        var s = Math.sin(toRadians(theta));
        r[0] = 1;
        r[4] = 0;
        r[8] = 0;
        r[12] = 0;
        r[1] = 0;
        r[5] = c;
        r[9] = -s;
        r[13] = 0;
        r[2] = 0;
        r[6] = s;
        r[10] = c;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Rotación sobre Y - glRotatef */
      function rotacionY(matriz, theta) {
        let r = new Array(16);
        var c = Math.cos(toRadians(theta));
        var s = Math.sin(toRadians(theta));
        r[0] = c;
        r[4] = 0;
        r[8] = s;
        r[12] = 0;
        r[1] = 0;
        r[5] = 1;
        r[9] = 0;
        r[13] = 0;
        r[2] = -s;
        r[6] = 0;
        r[10] = c;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Rotación sobre Z - glRotatef */
      function rotacionZ(matriz, theta) {
        let r = new Array(16);
        var c = Math.cos(toRadians(theta));
        var s = Math.sin(toRadians(theta));
        r[0] = c;
        r[4] = -s;
        r[8] = 0;
        r[12] = 0;
        r[1] = s;
        r[5] = c;
        r[9] = 0;
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = 1;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Proyección Paralela - glOrtho */
      function ortho(r, izq, der, abj, arr, cerca, lejos) {
        r[0] = 2 / (der - izq);
        r[4] = 0;
        r[8] = 0;
        r[12] = -(der + izq) / (der - izq);
        r[1] = 0;
        r[5] = 2 / (arr - abj);
        r[9] = 0;
        r[13] = -(arr + abj) / (arr - abj);
        r[2] = 0;
        r[6] = 0;
        r[10] = -2 / (lejos - cerca);
        r[14] = -(lejos + cerca) / (lejos - cerca);
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
      }

      /* Proyección Perspectiva - glFrustum */
      function frustum(r, izq, der, abj, arr, cerca, lejos) {
        r[0] = (2 * cerca) / (der - izq);
        r[4] = 0;
        r[8] = (der + izq) / (der - izq);
        r[12] = 0;
        r[1] = 0;
        r[5] = (2 * cerca) / (arr - abj);
        r[9] = (arr + abj) / (arr - abj);
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = -(lejos + cerca) / (lejos - cerca);
        r[14] = (-2 * lejos * cerca) / (lejos - cerca);
        r[3] = 0;
        r[7] = 0;
        r[11] = -1;
        r[15] = 0;
      }

      /* Proyección Perspectiva - gluPerspective */
      function perspective(r, fovy, aspecto, cerca, lejos) {
        var ang = fovy * 0.5;
        var f =
          (Math.abs(Math.sin(toRadians(ang))) < 1e-8 ? 0 : 1) /
          Math.tan(toRadians(ang));
        r[0] = f / aspecto;
        r[4] = 0;
        r[8] = 0;
        r[12] = 0;
        r[1] = 0;
        r[5] = f;
        r[9] = 0;
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = -(lejos + cerca) / (lejos - cerca);
        r[14] = (-2.0 * lejos * cerca) / (lejos - cerca);
        r[3] = 0;
        r[7] = 0;
        r[11] = -1.0;
        r[15] = 0;
      }

      /* Multiplicación de matrices de 4 x 4 */
      function multiplica(c, a, b) {
        let r = new Array(16);
        let i, j, k;
        for (i = 0; i < 4; i++) {
          for (j = 0; j < 4; j++) {
            let s = 0;
            for (k = 0; k < 4; k++) s = s + a[i + k * 4] * b[k + j * 4];
            r[i + j * 4] = s;
          }
        }
        for (i = 0; i < 16; i++) c[i] = r[i];
      }

      /***************************************************************************/
      /* La Clase Vector3                                                        */
      /***************************************************************************/

      class Vector3 {
        /**
         * Construye un nuevo Vector.
         */
        constructor(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        }

        /**
         *                   u = Suma de vectores
         *  u = v1 + v2     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         *                   u = (v1.x + v2.x, v1.y + v2.y, v1.z + v2.z)
         */
        mas(v2) {
          return new Vector3(this.x + v2.x, this.y + v2.y, this.z + v2.z);
        }

        /**
         *                   u = Resta de vectores
         *  u = v1 - v2     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         *                   u = (v1.x - v2.x, v1.y - v2.y, v1.z - v2.z)
         */
        menos(v2) {
          return new Vector3(this.x - v2.x, this.y - v2.y, this.z - v2.z);
        }

        /**
         *                      u x v = Producto vectorial o producto cruz
         * u = (u.x, u.y, u.z) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         * v = (v.x, v.y, v.z)  u x v = (u.y * v.z - u.z * v.y,
         *                               u.z * v.x - u.x * v.z,
         *                               u.x * v.y - u.y * v.x)
         */
        producto_vectorial(v2) {
          var r = new Vector3();
          r.x = this.y * v2.z - this.z * v2.y;
          r.y = this.z * v2.x - this.x * v2.z;
          r.z = this.x * v2.y - this.y * v2.x;
          return r;
        }

        /**
         *                      u . v = Producto escalar o producto punto
         * u = (u.x, u.y, u.z) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         * v = (v.x, v.y, v.z)  u . v = u.x v.x + u.y v.y + u.z v.z
         *
         */
        producto_escalar(v2) {
          return this.x * v2.x + this.y * v2.y + this.z * v2.z;
        }

        /**
         *                     |v| = Longitud de un vector o magnitud
         * v = (x, y, z)    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         *                     |v| = raiz_cuadrada (x^2 + y^2 + z^2)
         *
         */
        longitud() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }

        /**
         *        v            u = Vector unitario o de longitud 1
         *  u  = ---        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         *       |v|           u = Vector normalizado
         *
         */
        normaliza() {
          var l = this.longitud();
          if (l > 0) {
            this.x = this.x / l;
            this.y = this.y / l;
            this.z = this.z / l;
          }
        }
        /**
         *    3
         *     ^
         *     |
         *   v |
         *     |
         *    1 -------- > 2
         */
        normal(v1, v2, v3) {
          var u = new Vector3(); // vector u
          var v = new Vector3(); // vector v
          var n = new Vector3(); // vector n

          /* Calcula los vectores u y v */
          u = v2.menos(v1);
          v = v3.menos(v1);

          /* n = u x v */
          n = u.producto_vectorial(v);

          /* Normaliza */
          n.normaliza();

          return n;
        }

        toString() {
          return (
            "Vector3 [x=" + this.x + ", y=" + this.y + ", z=" + this.z + "]"
          );
        }
      }

      /***************************************************************************/
      /* ArcBall: Obtiene los vectores U y V de la esfera (x^2 + y^2 + z^2 = 1). */
      /***************************************************************************/

      var Punto2f = function (x, y) {
        // Atributos publicos
        this.x = x;
        this.y = y;
      };

      class ArcBall {
        /**
         * Construye un nuevo ArcBall.
         */
        constructor(w, h) {
          this.Epsilon = 1.0e-5;
          this.U = new Vector3();
          this.V = new Vector3();
          this.ajusta(w, h);
        }

        /* Ajusta el ancho y alto de la ventana */
        ajusta(w, h) {
          if (!(w > 1.0 && h > 1.0)) document.write("ERROR");

          /* Ajusta el factor para el ancho y alto (2 = [-1..1]) */
          this.ajustaAncho = 2.0 / (w - 1.0);
          this.ajustaAlto = 2.0 / (h - 1.0);
        }

        /* Obtiene el vector dado un punto (x,y) */
        obtieneVector(vector, x, y) {
          /* Copia punto */
          let temp = new Punto2f(x, y);

          /* Ajusta las coordenadas del punto al rango [-1..1] */
          temp.x = temp.x * this.ajustaAncho - 1.0;
          temp.y = 1.0 - temp.y * this.ajustaAlto;

          /* Calcula el cuadrado de la longitud del vector */
          let longitud2 = temp.x * temp.x + temp.y * temp.y;

          /*
           * Considerando que: radio^2 = x^2 + y^2 + z^2
           * ¿Cuales son los valores de x, y y z?
           *
           * Si el punto está fuera de la esfera... (longitud2 > 1)
           */

          if (longitud2 > 1.0) {
            /* Calcula un factor de normalización (radio / sqrt(longitud2)) */
            let norma = 1.0 / Math.sqrt(longitud2);

            /* Retorna el vector "normalizado", un punto sobre la esfera */
            vector.x = temp.x * norma;
            vector.y = temp.y * norma;
            vector.z = 0.0;
          } else {
            /* e.o.c. está dentro */
            /*
             * Retorna un vector, un punto dentro la esfera
             * z = sqrt(radio^cuadrado - (x^2 + y^2))
             */
            vector.x = temp.x;
            vector.y = temp.y;
            vector.z = Math.sqrt(1.0 - longitud2);
          }
        }

        /* Obtiene el vector U */
        primerPunto(x, y) {
          this.obtieneVector(this.U, x, y);
        }

        /* Obtiene el Cuaternion de U y V */
        segundoPunto(x, y) {
          let q = new Cuaternion();

          /* Obtiene el vector V */
          this.obtieneVector(this.V, x, y);

          /* Retorna el cuaternión equivalente a la rotación. */
          if (q != null) {
            /* Calcula la Normal = U x V */
            let Normal = this.U.producto_vectorial(this.V);

            /* Calcula la longitud de la normal */
            if (Normal.longitud() > this.Epsilon) {
              /* si no es cero */
              q.x = Normal.x;
              q.y = Normal.y;
              q.z = Normal.z;
              /* w  = (theta / 2), donde theta es el ángulo de rotación */
              q.w = this.U.producto_escalar(this.V);
            } else {
              /* si es cero */
              /* U y V coinciden */
              q.x = q.y = q.z = q.w = 0.0;
            }
          }
          return q;
        }
      }

      /***************************************************************************/
      /* Cuaternion: Realiza las operaciones de los cuaterniones.                */
      /***************************************************************************/

      class Cuaternion {
        /**
         * Construye un nuevo Cuaternion.
         */
        constructor(w, x, y, z) {
          this.w = w;
          this.x = x;
          this.y = y;
          this.z = z;
        }

        inicializa(w, v) {
          this.w = w;
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
        }

        // norma^2 = w^2 + x^2 + y^2 + z^2
        norma2() {
          return (
            this.w * this.w +
            this.x * this.x +
            this.y * this.y +
            this.z * this.z
          );
        }

        // Conjugado
        conjugado() {
          x = -this.x;
          y = -this.y;
          z = -this.z;
          return this;
        }

        // Cuaternion q = Cuaternion a . Cuaternion b
        multiplica(a, b) {
          let q = new Cuaternion(0, 0, 0, 0);
          q.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
          q.x = a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y;
          q.y = a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x;
          q.z = a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w;
          return q;
        }

        // Cuaternion q = Cuaternion a . b
        multiplica_escalar(a, b) {
          let q = new Cuaternion(0, 0, 0, 0);
          q.w = a.w * b;
          q.x = a.x * b;
          q.y = a.y * b;
          q.z = a.z * b;
          return q;
        }

        // q' = q . p . q^(-1)
        rota(q, p) {
          // q es Cuaternion y p es Vector3
          let p_homogeneo = new Cuaternion(0, 0, 0, 0);
          p_homogeneo.inicializa(0, p);
          let p_prima = this.multiplica(
            q,
            this.multiplica(p_homogeneo, q.inverso())
          );
          return new Vector3(p_prima.x, p_prima.y, p_prima.z);
        }

        // q' = q . p . q*
        rota1(q, p) {
          // q es Cuaternion y p es Vector3
          let p_homogeneo = new Cuaternion(0, 0, 0, 0);
          p_homogeneo.inicializa(0, p);
          let p_prima = this.multiplica(
            q,
            this.multiplica(p_homogeneo, q.conjugado())
          );
          return new Vector3(p_prima.x, p_prima.y, p_prima.z);
        }

        // q = q^(-1)
        inverso() {
          let q = new Cuaternion(0, 0, 0, 0);
          // normal^2 = a . b
          let n = this.norma2();
          if (n <= 1e-8) document.write("INVERSO: Error");
          q = multiplica_escalar(
            new Cuaternion(this.w, -this.x, -this.y, -this.z),
            1 / n
          );
          return q;
        }

        /* Convierte el cuaternión a una matriz de rotación */
        static rota2(a, q) {
          let d, s;
          d = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;
          s = d > 0.0 ? 2.0 / d : 0.0;
          a[0] = 1.0 - (q.y * q.y + q.z * q.z) * s;
          a[4] = (q.x * q.y - q.w * q.z) * s;
          a[8] = (q.x * q.z + q.w * q.y) * s;
          a[12] = 0;
          a[1] = (q.x * q.y + q.w * q.z) * s;
          a[5] = 1.0 - (q.x * q.x + q.z * q.z) * s;
          a[9] = (q.y * q.z - q.w * q.x) * s;
          a[13] = 0;
          a[2] = (q.x * q.z - q.w * q.y) * s;
          a[6] = (q.y * q.z + q.w * q.x) * s;
          a[10] = 1.0 - (q.x * q.x + q.y * q.y) * s;
          a[14] = 0;
          a[3] = 0;
          a[7] = 0;
          a[11] = 0;
          a[15] = 1;
        }

        toString() {
          return (
            "Cuaternion [w=" +
            this.w +
            ", x=" +
            this.x +
            ", y=" +
            this.y +
            ", z=" +
            this.z +
            "]"
          );
        }
      }

      /***********************************************************************************/
      /* Se define la geometría y se almacenan en los buffers de memoria y se renderiza. */
      /***********************************************************************************/
      class Cubo {
        /**
         * @param {WebGL2RenderingContext} gl
         * @param {Array<number>} [colorUniform]  // [r, g, b, a] opcional
         */
        constructor(gl, colorUniform = null) {
          // 1) Vertices de un cubo unitario
          const vertices = [
            // Frente
            -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1,
            // Atrás
            -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1,
            // Izquierda
            -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1,
            // Derecha
            1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1,
            // Abajo
            -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1,
            // Arriba
            -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1,
          ];

          // 2) Colores: o bien todo negro (o el que le pases), o el arcoíris original
          const totalVerts = vertices.length / 3;
          let colores = new Float32Array(totalVerts * 4);

          if (colorUniform) {
            // relleno uniforme
            for (let i = 0; i < totalVerts; i++) {
              colores.set(colorUniform, i * 4);
            }
          } else {
            // tu array de colores “arcoíris” (24 vértices × 4 componentes)
            const orig = [
              // Frente (lila)
              1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1,
              // Atrás (amarillo)
              1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1,
              // Izquierda (celeste)
              0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1,
              // Derecha (rojo)
              1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1,
              // Abajo (azul)
              0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
              // Arriba (verde)
              0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            ];
            colores.set(orig);
          }

          // 3) Índices para gl.drawElements
          const indices = [
            0,
            1,
            2,
            0,
            2,
            3, // Frente
            4,
            5,
            6,
            4,
            6,
            7, // Atrás
            8,
            9,
            10,
            8,
            10,
            11, // Izquierda
            12,
            13,
            14,
            12,
            14,
            15, // Derecha
            16,
            17,
            18,
            16,
            18,
            19, // Abajo
            20,
            21,
            22,
            20,
            22,
            23, // Arriba
          ];

          // --- CREACIÓN DE VAO + BUFFERS ---
          this.vao = gl.createVertexArray();
          gl.bindVertexArray(this.vao);

          // posiciones
          const bufPos = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, bufPos);
          gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(vertices),
            gl.STATIC_DRAW
          );
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

          // colores
          const bufCol = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, bufCol);
          gl.bufferData(gl.ARRAY_BUFFER, colores, gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

          // índices
          const bufIdx = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufIdx);
          gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indices),
            gl.STATIC_DRAW
          );

          // desenlazamos
          gl.bindVertexArray(null);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

          this.indexCount = indices.length;
        }

        dibuja(gl) {
          gl.bindVertexArray(this.vao);
          gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
          gl.bindVertexArray(null);
        }
      }

      class Cilindro {
        constructor(
          gl,
          radio,
          alto,
          sectores,
          colorRGBA,
          capTop = true,
          capBottom = true
        ) {
          this.radio = radio;
          this.alto = alto;
          this.gl = gl;
          this.sectores = sectores;
          const posiciones = [];

          // Vertices laterales (2 por sector: inferior y superior)
          for (let i = 0; i <= sectores; i++) {
            const theta = (i / sectores) * 2 * Math.PI;
            const x = radio * Math.cos(theta);
            const z = radio * Math.sin(theta);
            posiciones.push(x, -alto / 2, z);
            posiciones.push(x, alto / 2, z);
          }

          // Opcional: centro de tapa superior
          let idxCentroTop = -1;
          if (capTop) {
            idxCentroTop = posiciones.length / 3;
            posiciones.push(0, alto / 2, 0);
          }

          // Opcional: centro de tapa inferior
          let idxCentroBot = -1;
          if (capBottom) {
            idxCentroBot = posiciones.length / 3;
            posiciones.push(0, -alto / 2, 0);
          }

          // Construir índices
          const indices = [];
          // Caras laterales
          for (let i = 0; i < sectores; i++) {
            const base = i * 2;
            const next = base + 2;
            // Triángulos de la cara
            indices.push(base, next, next + 1);
            indices.push(base, next + 1, base + 1);
          }
          // Tapa superior
          if (capTop) {
            for (let i = 0; i < sectores; i++) {
              const topVert = i * 2 + 1;
              const nextTop = ((i + 1) * 2 + 1) % ((sectores + 1) * 2);
              indices.push(idxCentroTop, topVert, nextTop);
            }
          }
          // Tapa inferior
          if (capBottom) {
            for (let i = 0; i < sectores; i++) {
              const botVert = i * 2;
              const nextBot = ((i + 1) * 2) % ((sectores + 1) * 2);
              indices.push(idxCentroBot, nextBot, botVert);
            }
          }

          this.indexCount = indices.length;

          // Crear VAO
          this.vao = gl.createVertexArray();
          gl.bindVertexArray(this.vao);

          // Buffer de posiciones
          const posBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
          gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(posiciones),
            gl.STATIC_DRAW
          );
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

          // Buffer de colores (un color uniforme)
          const totalVerts = posiciones.length / 3;
          const colores = new Float32Array(totalVerts * 4);
          for (let i = 0; i < totalVerts; i++) {
            colores.set(colorRGBA, i * 4);
          }
          this.coloresBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, this.coloresBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, colores, gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

          // Buffer de índices
          const idxBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
          gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indices),
            gl.STATIC_DRAW
          );

          // Desactivar VAO
          gl.bindVertexArray(null);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }

        dibuja(gl) {
          gl.bindVertexArray(this.vao);
          gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
          gl.bindVertexArray(null);
        }
      }
      class Esfera {
        constructor(gl, radio, stacks, slices, colorRGBA) {
          this.radio = radio;
          const posiciones = [];
          const indices = [];
          // Generar vértices
          for (let stack = 0; stack <= stacks; stack++) {
            const phi = (Math.PI * stack) / stacks; // de 0 a PI
            const y = radio * Math.cos(phi);
            const r = radio * Math.sin(phi);
            for (let slice = 0; slice <= slices; slice++) {
              const theta = (2 * Math.PI * slice) / slices; // de 0 a 2PI
              const x = r * Math.cos(theta);
              const z = r * Math.sin(theta);
              posiciones.push(x, y, z);
            }
          }
          // Triangulación: quad entre stacks y slices
          for (let stack = 0; stack < stacks; stack++) {
            for (let slice = 0; slice < slices; slice++) {
              const first = stack * (slices + 1) + slice;
              const second = first + (slices + 1);
              indices.push(first, second, first + 1);
              indices.push(second, second + 1, first + 1);
            }
          }
          this.indexCount = indices.length;
          // Crear VAO
          this.vao = gl.createVertexArray();
          gl.bindVertexArray(this.vao);
          // Buffer posiciones
          const posBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
          gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(posiciones),
            gl.STATIC_DRAW
          );
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
          // Buffer colores uniforme
          const totalVerts = posiciones.length / 3;
          const colores = new Float32Array(totalVerts * 4);
          for (let i = 0; i < totalVerts; i++) colores.set(colorRGBA, i * 4);
          const colorBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, colores, gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
          // Buffer índices
          const idxBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
          gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indices),
            gl.STATIC_DRAW
          );
          // Desactivar VAO
          gl.bindVertexArray(null);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }

        dibuja(gl) {
          gl.bindVertexArray(this.vao);
          gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
          gl.bindVertexArray(null);
        }
      }

      class MuñecoNieve {
        constructor(
          gl,
          {
            scale = 1,
            bodyColor = [1, 1, 1, 1],
            hatColor = [0, 0, 0, 1],
            noseColor = [1, 0.5, 0, 1],
          } = {}
        ) {
          this.gl = gl;
          this.scale = scale;
          this.colors = { body: bodyColor, hat: hatColor, nose: noseColor };

          // --- parámetros geométricos básicos ---
          const stacks = 16,
            slices = 16;
          const R_base = 1.0,
            R_tronco = 0.7,
            R_cabeza = 0.5;
          const H_nariz = 0.6,
            R_nariz = 0.1;
          const H_ala = 0.1,
            R_ala = R_cabeza * 1.2;
          const H_copa = 0.5,
            R_copa = 0.4;
          const R_ojo = 0.05;

          // Crear las piezas
          this.base = new Esfera(gl, R_base, stacks, slices, this.colors.body);
          this.tronco = new Esfera(
            gl,
            R_tronco,
            stacks,
            slices,
            this.colors.body
          );
          this.cabeza = new Esfera(
            gl,
            R_cabeza,
            stacks,
            slices,
            this.colors.body
          );

          this.hatAla = new Cilindro(
            gl,
            R_ala,
            H_ala,
            32,
            this.colors.hat,
            true,
            true
          );
          this.hatCopa = new Cilindro(
            gl,
            R_copa,
            H_copa,
            32,
            this.colors.hat,
            true,
            true
          );

          this.nariz = new Cilindro(
            gl,
            R_nariz,
            H_nariz,
            32,
            this.colors.nose,
            true,
            true
          );

          // ojos negros
          this.ojo1 = new Esfera(gl, R_ojo, stacks, slices, [0, 0, 0, 1]);
          this.ojo2 = new Esfera(gl, R_ojo, stacks, slices, [0, 0, 0, 1]);
        }

        /** Cambia la escala global */
        setScale(f) {
          this.scale = f;
        }

        /**
         * @param {Object} cols
         * @param {Array<number>} cols.body
         * @param {Array<number>} cols.hat
         * @param {Array<number>} cols.nose
         */
        setColors({ body, hat, nose }) {
          if (body) this.colors.body = body;
          if (hat) this.colors.hat = hat;
          if (nose) this.colors.nose = nose;
          // si quieres que cambie en tiempo real, habría que reenlazar buffers o reinstanciar:
          this.base = new Esfera(
            this.gl,
            this.base.radio,
            16,
            16,
            this.colors.body
          );
          this.tronco = new Esfera(
            this.gl,
            this.tronco.radio,
            16,
            16,
            this.colors.body
          );
          this.cabeza = new Esfera(
            this.gl,
            this.cabeza.radio,
            16,
            16,
            this.colors.body
          );
          this.hatAla = new Cilindro(
            this.gl,
            this.hatAla.radio,
            this.hatAla.alto,
            32,
            this.colors.hat,
            true,
            true
          );
          this.hatCopa = new Cilindro(
            this.gl,
            this.hatCopa.radio,
            this.hatCopa.alto,
            32,
            this.colors.hat,
            true,
            true
          );
          this.nariz = new Cilindro(
            this.gl,
            this.nariz.radio,
            this.nariz.alto,
            32,
            this.colors.nose,
            true,
            true
          );
        }
        draw(shaderProgram) {
          const gl = this.gl;
          const locM = gl.getUniformLocation(shaderProgram, "uMatrizModelo");

          // 1) Coge la matriz global de cámara + zoom + rotación
          const M = MatrizModelo.slice();

          // 2) Dibuja cada parte clonando M antes de traducir
          let mTmp;

          // Base
          mTmp = M.slice();
          traslacion(mTmp, 0, this.base.radio, 0);
          gl.uniformMatrix4fv(locM, false, mTmp);
          this.base.dibuja(gl);

          // Tronco
          mTmp = M.slice();
          traslacion(mTmp, 0, this.base.radio * 2 + this.tronco.radio - 0.2, 0);
          gl.uniformMatrix4fv(locM, false, mTmp);
          this.tronco.dibuja(gl);

          // Cabeza
          const yCabeza =
            this.base.radio * 2 +
            this.tronco.radio * 2 +
            this.cabeza.radio -
            0.4;
          mTmp = M.slice();
          traslacion(mTmp, 0, yCabeza, 0);
          gl.uniformMatrix4fv(locM, false, mTmp);
          this.cabeza.dibuja(gl);

          // Ojos
          const ojoY = yCabeza + this.cabeza.radio * 0.2;
          const ojoZ = this.cabeza.radio * 0.9;
          [-0.2, 0.2].forEach((xPos, i) => {
            mTmp = M.slice();
            traslacion(mTmp, xPos, ojoY, ojoZ);
            gl.uniformMatrix4fv(locM, false, mTmp);
            (i === 0 ? this.ojo1 : this.ojo2).dibuja(gl);
          });

          // Nariz
          mTmp = M.slice();
          traslacion(mTmp, 0, yCabeza, this.cabeza.radio);
          rotacionX(mTmp, 90);
          gl.uniformMatrix4fv(locM, false, mTmp);
          this.nariz.dibuja(gl);

          // Sombrero - ala
          const ySombr = yCabeza + this.cabeza.radio + 0.01;
          mTmp = M.slice();
          traslacion(mTmp, 0, ySombr, 0);
          gl.uniformMatrix4fv(locM, false, mTmp);
          this.hatAla.dibuja(gl);

          // Sombrero - copa
          mTmp = M.slice();
          traslacion(
            mTmp,
            0,
            ySombr + this.hatAla.alto / 2 + this.hatCopa.alto / 2,
            0
          );
          gl.uniformMatrix4fv(locM, false, mTmp);
          this.hatCopa.dibuja(gl);
        }
      }

      /***************************************************************************/
      /* Eventos del Ratón                                                       */
      /***************************************************************************/

      function mouseDown(event) {
        var posx = new Number();
        var posy = new Number();

        /* Obtiene la coordenada dentro de la área mayor */
        if (event.x != undefined && event.y != undefined) {
          posx = event.x;
          posy = event.y;
        } else {
          posx =
            event.clientX +
            document.body.scrollLeft +
            document.documentElement.scrollLeft;
          posy =
            event.clientY +
            document.body.scrollTop +
            document.documentElement.scrollTop;
        }

        /* Obtiene la coordenada dentro del canvas */
        posx = posx - canvas.offsetLeft;
        posy = posy - canvas.offsetTop;

        if (event.button == 0) {
          // botón izquierdo
          Matriz = MatrizRotacion.slice(); /* Copia */
          arcBall.primerPunto(posx, posy);
          boton_izq_presionado = true;
        } else if (event.button == 2)
          // botón derecho
          boton_der_presionado = true;

        return false;
      }

      function mouseUp(e) {
        boton_izq_presionado = false;
        boton_der_presionado = false;
      }

      function mouseMove(event) {
        var posx = new Number();
        var posy = new Number();

        /* Obtiene la coordenada dentro de la área mayor */
        if (event.x != undefined && event.y != undefined) {
          posx = event.x;
          posy = event.y;
        } else {
          posx =
            event.clientX +
            document.body.scrollLeft +
            document.documentElement.scrollLeft;
          posy =
            event.clientY +
            document.body.scrollTop +
            document.documentElement.scrollTop;
        }

        /* Obtiene la coordenada dentro del canvas */
        posx = posx - canvas.offsetLeft;
        posy = posy - canvas.offsetTop;

        if (boton_izq_presionado) {
          let q = arcBall.segundoPunto(posx, posy);
          Cuaternion.rota2(MatrizRotacion, q);
          multiplica(MatrizRotacion, MatrizRotacion, Matriz);
        } else if (boton_der_presionado) {
          posx = (posx * 10) / canvas.width - 5;
          posy = 10 - (posy * 10) / canvas.height - 5;
          tx = posx;
          ty = posy;
        }
      }

      function zoom(event) {
        event.preventDefault();
        if (event.deltaY > 0) {
          sx = sx * 0.9;
          sy = sy * 0.9;
          sz = sz * 0.9;
        } else {
          sx = sx * 1.1;
          sy = sy * 1.1;
          sz = sz * 1.1;
        }
      }

      function dibuja() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        identidad(MatrizModelo);
        traslacion(MatrizModelo, tx, ty, 0);
        escalacion(MatrizModelo, sx, sy, sz);
        multiplica(MatrizModelo, MatrizModelo, MatrizRotacion);
        // Aplicar rotaciones manuales:
        angleX = (angleX + speedY / 90) % 360;
        angleY = (angleY + speedX / 90) % 360;
        angleZ = (angleZ + speedZ / 90) % 360;

        // rota
        rotacionX(MatrizModelo, angleX);
        rotacionY(MatrizModelo, angleY);
        rotacionZ(MatrizModelo, angleZ);

        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

        if (showFloor) {
          suelo = new Cubo(gl, floorColorRGBA);
          let Msuelo = MatrizModelo.slice();
          traslacion(Msuelo, 0, -0.5, 0);
          escalacion(Msuelo, 5, 0.5, 5);
          gl.uniformMatrix4fv(uMatrizModelo, false, Msuelo);
          suelo.dibuja(gl);
        }

        let Mmuñeco = MatrizModelo.slice();
        escalacion(Mmuñeco, 2, 2, 2);
        gl.uniformMatrix4fv(uMatrizModelo, false, Mmuñeco);
        muñeco.draw(programaID);

        requestAnimationFrame(dibuja);
      }

      function reinicia() {
        tx = 0;
        ty = 0;
        (sx = 0.4), (sy = 0.4), (sz = 0.4);
        speedY = 0;
        speedX = 0;
        speedZ = 0;

        angleX = 0;
        angleY = 0;
        angleZ = 0;
        identidad(MatrizRotacion);

        dibuja();
      }

      function ajustaTamaño() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        arcBall.ajusta(canvas.width, canvas.height);
      }

      function hexToRGBA(hex) {
        const v = parseInt(hex.slice(1), 16);
        return [
          ((v >> 16) & 255) / 255,
          ((v >> 8) & 255) / 255,
          (v & 255) / 255,
          1,
        ];
      }

      function main() {
        canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl2");
        if (!gl) {
          document.write("WebGL 2.0 no está disponible en tu navegador");
          return;
        }
        canvas.addEventListener("mousedown", mouseDown, false);
        canvas.addEventListener("mouseup", mouseUp, false);
        canvas.addEventListener("mouseout", mouseUp, false);
        canvas.addEventListener("mousemove", mouseMove, false);
        canvas.addEventListener("wheel", zoom, { passive: false });
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        compilaEnlazaLosShaders();
        suelo = new Cubo(gl, [0, 0, 0, 1]);
        muñeco = new MuñecoNieve(gl, {
          scale: 1.0,
          bodyColor: [1, 1, 1, 1],
          hatColor: [0, 0, 0, 1],
          noseColor: [1, 0.5, 0, 1],
        });
        arcBall = new ArcBall(500.0, 500.0);

        document.getElementById("rotX").oninput = (e) =>
          (speedX = +e.target.value);
        document.getElementById("rotY").oninput = (e) =>
          (speedY = +e.target.value);
        document.getElementById("rotZ").oninput = (e) =>
          (speedZ = +e.target.value);

        document.getElementById("toggleFloor").onchange = (e) =>
          (showFloor = e.target.checked);

        document.getElementById("floorColor").oninput = (e) => {
          const rgba = hexToRGBA(e.target.value);
          floorColorRGBA = rgba;
        };

        document.getElementById("bodyColor").oninput = (e) =>
          muñeco.setColors({ body: hexToRGBA(e.target.value) });
        document.getElementById("hatColor").oninput = (e) =>
          muñeco.setColors({ hat: hexToRGBA(e.target.value) });
        document.getElementById("noseColor").oninput = (e) =>
          muñeco.setColors({ nose: hexToRGBA(e.target.value) });
        document.getElementById("resetBtn").onclick = reinicia;

        window.addEventListener("resize", ajustaTamaño);
        ajustaTamaño();

        gl.useProgram(programaID);
        uMatrizProyeccion = gl.getUniformLocation(
          programaID,
          "uMatrizProyeccion"
        );
        uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
        uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");

        ortho(MatrizProyeccion, -5, 5, -5, 5, -5, 5);
        gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
        identidad(MatrizVista);
        gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
        identidad(MatrizRotacion);
        arcBall.ajusta(gl.canvas.width, gl.canvas.height);
        identidad(Matriz);

        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0.0, 0.0, 0.3, 1.0);

        dibuja();
      }
      window.onload = main;
    </script>
  </body>
</html>
