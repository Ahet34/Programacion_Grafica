<!DOCTYPE html>
<html>
  <head>
    <title>Cubo Color Interacción (Cuaternión) en WebGL 2.0</title>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0px;
        border: 0;
        overflow: hidden; /* Deshabilita las barras de desplazamiento */
        display: block; /* Sin contenido flotantes a los lados */
      }
    </style>
  </head>
  <body>
    <div id="content">
      <div id="canvas-holder">
        <canvas
          id="webglcanvas"
          style="border: none"
          width="2000"
          height="1000"
        ></canvas>
        <p id="reset"></p>
      </div>
    </div>

    <!--
        /***************************************************************************/
        /* Se definen los códigos shaders.                                         */
        /***************************************************************************/
      -->
    <script id="vs" type="vertex">
      #version 300 es
      uniform mat4 uMatrizProyeccion;
      uniform mat4 uMatrizVista;
      uniform mat4 uMatrizModelo;
      layout(location = 0) in vec3 aVertices;
      layout(location = 1) in vec4 aColores;
      out vec4 vColores;
      void main() {
        vColores = aColores;
        gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
      }
    </script>

    <script id="fs" type="fragment">
      #version 300 es
      precision highp float;
      in vec4 vColores;
      out vec4 color;
      void main() {
          color = vColores;
      }
    </script>

    <script>
      "use strict";

      /* Variables globales */
      var canvas;
      var programaID;
      var gl;
      var cubo;
      var arcBall;
      // ↓ justo tras "var cubo;"
      var edificios, arboles;

      /* Variables Uniformes */
      var uMatrizProyeccion;
      var uMatrizVista;
      var uMatrizModelo;

      /* Matrices */
      var MatrizProyeccion = new Array(16);
      var MatrizVista = new Array(16);
      var MatrizModelo = new Array(16);

      /* Para la interacción */
      var MatrizRotacion = new Array(16);
      var Matriz = new Array(16);
      var boton_izq_presionado = false;

      /***************************************************************************/
      /* Se crean, compilan y enlazan los programas Shader                       */
      /***************************************************************************/
      function compilaEnlazaLosShaders() {
        /* Se compila el shader de vertice */
        var shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(
          shaderDeVertice,
          document.getElementById("vs").text.trim()
        );
        gl.compileShader(shaderDeVertice);
        if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shaderDeVertice));
        }

        /* Se compila el shader de fragmento */
        var shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(
          shaderDeFragmento,
          document.getElementById("fs").text.trim()
        );
        gl.compileShader(shaderDeFragmento);
        if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shaderDeFragmento));
        }

        /* Se enlaza ambos shader */
        programaID = gl.createProgram();
        gl.attachShader(programaID, shaderDeVertice);
        gl.attachShader(programaID, shaderDeFragmento);
        gl.linkProgram(programaID);
        if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(programaID));
        }

        /* Se instala el programa de shaders para utilizarlo */
        gl.useProgram(programaID);
      }

      /***************************************************************************/
      /* Transformaciones mediante matrices                                      */
      /***************************************************************************/

      /* Convierte de grados a radianes */
      function toRadians(grados) {
        return (grados * Math.PI) / 180;
      }

      /* Matriz Identidad */
      function identidad(r) {
        r[0] = 1;
        r[4] = 0;
        r[8] = 0;
        r[12] = 0;
        r[1] = 0;
        r[5] = 1;
        r[9] = 0;
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = 1;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
      }

      /* Traslación - glTranslatef */
      function traslacion(matriz, tx, ty, tz) {
        var r = new Array(16);
        r[0] = 1;
        r[4] = 0;
        r[8] = 0;
        r[12] = tx;
        r[1] = 0;
        r[5] = 1;
        r[9] = 0;
        r[13] = ty;
        r[2] = 0;
        r[6] = 0;
        r[10] = 1;
        r[14] = tz;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Escalación - glScalef */
      function escalacion(matriz, sx, sy, sz) {
        var r = new Array(16);
        r[0] = sx;
        r[4] = 0;
        r[8] = 0;
        r[12] = 0;
        r[1] = 0;
        r[5] = sy;
        r[9] = 0;
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = sz;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Rotación sobre X - glRotatef */
      function rotacionX(matriz, theta) {
        let r = new Array(16);
        var c = Math.cos(toRadians(theta));
        var s = Math.sin(toRadians(theta));
        r[0] = 1;
        r[4] = 0;
        r[8] = 0;
        r[12] = 0;
        r[1] = 0;
        r[5] = c;
        r[9] = -s;
        r[13] = 0;
        r[2] = 0;
        r[6] = s;
        r[10] = c;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Rotación sobre Y - glRotatef */
      function rotacionY(matriz, theta) {
        let r = new Array(16);
        var c = Math.cos(toRadians(theta));
        var s = Math.sin(toRadians(theta));
        r[0] = c;
        r[4] = 0;
        r[8] = s;
        r[12] = 0;
        r[1] = 0;
        r[5] = 1;
        r[9] = 0;
        r[13] = 0;
        r[2] = -s;
        r[6] = 0;
        r[10] = c;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Rotación sobre Z - glRotatef */
      function rotacionZ(matriz, theta) {
        let r = new Array(16);
        var c = Math.cos(toRadians(theta));
        var s = Math.sin(toRadians(theta));
        r[0] = c;
        r[4] = -s;
        r[8] = 0;
        r[12] = 0;
        r[1] = s;
        r[5] = c;
        r[9] = 0;
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = 1;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Proyección Paralela - glOrtho */
      function ortho(r, izq, der, abj, arr, cerca, lejos) {
        r[0] = 2 / (der - izq);
        r[4] = 0;
        r[8] = 0;
        r[12] = -(der + izq) / (der - izq);
        r[1] = 0;
        r[5] = 2 / (arr - abj);
        r[9] = 0;
        r[13] = -(arr + abj) / (arr - abj);
        r[2] = 0;
        r[6] = 0;
        r[10] = -2 / (lejos - cerca);
        r[14] = -(lejos + cerca) / (lejos - cerca);
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
      }

      /* Proyección Perspectiva - glFrustum */
      function frustum(r, izq, der, abj, arr, cerca, lejos) {
        r[0] = (2 * cerca) / (der - izq);
        r[4] = 0;
        r[8] = (der + izq) / (der - izq);
        r[12] = 0;
        r[1] = 0;
        r[5] = (2 * cerca) / (arr - abj);
        r[9] = (arr + abj) / (arr - abj);
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = -(lejos + cerca) / (lejos - cerca);
        r[14] = (-2 * lejos * cerca) / (lejos - cerca);
        r[3] = 0;
        r[7] = 0;
        r[11] = -1;
        r[15] = 0;
      }

      /* Proyección Perspectiva - gluPerspective */
      function perspective(r, fovy, aspecto, cerca, lejos) {
        var ang = fovy * 0.5;
        var f =
          (Math.abs(Math.sin(toRadians(ang))) < 1e-8 ? 0 : 1) /
          Math.tan(toRadians(ang));
        r[0] = f / aspecto;
        r[4] = 0;
        r[8] = 0;
        r[12] = 0;
        r[1] = 0;
        r[5] = f;
        r[9] = 0;
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = -(lejos + cerca) / (lejos - cerca);
        r[14] = (-2.0 * lejos * cerca) / (lejos - cerca);
        r[3] = 0;
        r[7] = 0;
        r[11] = -1.0;
        r[15] = 0;
      }

      /* Multiplicación de matrices de 4 x 4 */
      function multiplica(c, a, b) {
        let r = new Array(16);
        let i, j, k;
        for (i = 0; i < 4; i++) {
          for (j = 0; j < 4; j++) {
            let s = 0;
            for (k = 0; k < 4; k++) s = s + a[i + k * 4] * b[k + j * 4];
            r[i + j * 4] = s;
          }
        }
        for (i = 0; i < 16; i++) c[i] = r[i];
      }

      /***************************************************************************/
      /* La Clase Vector3                                                        */
      /***************************************************************************/

      class Vector3 {
        /**
         * Construye un nuevo Vector.
         */
        constructor(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        }

        /**
         *                   u = Suma de vectores
         *  u = v1 + v2     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         *                   u = (v1.x + v2.x, v1.y + v2.y, v1.z + v2.z)
         */
        mas(v2) {
          return new Vector3(this.x + v2.x, this.y + v2.y, this.z + v2.z);
        }

        /**
         *                   u = Resta de vectores
         *  u = v1 - v2     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         *                   u = (v1.x - v2.x, v1.y - v2.y, v1.z - v2.z)
         */
        menos(v2) {
          return new Vector3(this.x - v2.x, this.y - v2.y, this.z - v2.z);
        }

        /**
         *                      u x v = Producto vectorial o producto cruz
         * u = (u.x, u.y, u.z) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         * v = (v.x, v.y, v.z)  u x v = (u.y * v.z - u.z * v.y,
         *                               u.z * v.x - u.x * v.z,
         *                               u.x * v.y - u.y * v.x)
         */
        producto_vectorial(v2) {
          var r = new Vector3();
          r.x = this.y * v2.z - this.z * v2.y;
          r.y = this.z * v2.x - this.x * v2.z;
          r.z = this.x * v2.y - this.y * v2.x;
          return r;
        }

        /**
         *                      u . v = Producto escalar o producto punto
         * u = (u.x, u.y, u.z) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         * v = (v.x, v.y, v.z)  u . v = u.x v.x + u.y v.y + u.z v.z
         *
         */
        producto_escalar(v2) {
          return this.x * v2.x + this.y * v2.y + this.z * v2.z;
        }

        /**
         *                     |v| = Longitud de un vector o magnitud
         * v = (x, y, z)    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         *                     |v| = raiz_cuadrada (x^2 + y^2 + z^2)
         *
         */
        longitud() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }

        /**
         *        v            u = Vector unitario o de longitud 1
         *  u  = ---        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         *       |v|           u = Vector normalizado
         *
         */
        normaliza() {
          var l = this.longitud();
          if (l > 0) {
            this.x = this.x / l;
            this.y = this.y / l;
            this.z = this.z / l;
          }
        }
        /**
         *    3
         *     ^
         *     |
         *   v |
         *     |
         *    1 -------- > 2
         */
        normal(v1, v2, v3) {
          var u = new Vector3(); // vector u
          var v = new Vector3(); // vector v
          var n = new Vector3(); // vector n

          /* Calcula los vectores u y v */
          u = v2.menos(v1);
          v = v3.menos(v1);

          /* n = u x v */
          n = u.producto_vectorial(v);

          /* Normaliza */
          n.normaliza();

          return n;
        }

        toString() {
          return (
            "Vector3 [x=" + this.x + ", y=" + this.y + ", z=" + this.z + "]"
          );
        }
      }

      /***************************************************************************/
      /* ArcBall: Obtiene los vectores U y V de la esfera (x^2 + y^2 + z^2 = 1). */
      /***************************************************************************/

      var Punto2f = function (x, y) {
        // Atributos publicos
        this.x = x;
        this.y = y;
      };

      class ArcBall {
        /**
         * Construye un nuevo ArcBall.
         */
        constructor(w, h) {
          this.Epsilon = 1.0e-5;
          this.U = new Vector3();
          this.V = new Vector3();
          this.ajusta(w, h);
        }

        /* Ajusta el ancho y alto de la ventana */
        ajusta(w, h) {
          if (!(w > 1.0 && h > 1.0)) document.write("ERROR");

          /* Ajusta el factor para el ancho y alto (2 = [-1..1]) */
          this.ajustaAncho = 2.0 / (w - 1.0);
          this.ajustaAlto = 2.0 / (h - 1.0);
        }

        /* Obtiene el vector dado un punto (x,y) */
        obtieneVector(vector, x, y) {
          /* Copia punto */
          let temp = new Punto2f(x, y);

          /* Ajusta las coordenadas del punto al rango [-1..1] */
          temp.x = temp.x * this.ajustaAncho - 1.0;
          temp.y = 1.0 - temp.y * this.ajustaAlto;

          /* Calcula el cuadrado de la longitud del vector */
          let longitud2 = temp.x * temp.x + temp.y * temp.y;

          /*
           * Considerando que: radio^2 = x^2 + y^2 + z^2
           * ¿Cuales son los valores de x, y y z?
           *
           * Si el punto está fuera de la esfera... (longitud2 > 1)
           */

          if (longitud2 > 1.0) {
            /* Calcula un factor de normalización (radio / sqrt(longitud2)) */
            let norma = 1.0 / Math.sqrt(longitud2);

            /* Retorna el vector "normalizado", un punto sobre la esfera */
            vector.x = temp.x * norma;
            vector.y = temp.y * norma;
            vector.z = 0.0;
          } else {
            /* e.o.c. está dentro */
            /*
             * Retorna un vector, un punto dentro la esfera
             * z = sqrt(radio^cuadrado - (x^2 + y^2))
             */
            vector.x = temp.x;
            vector.y = temp.y;
            vector.z = Math.sqrt(1.0 - longitud2);
          }
        }

        /* Obtiene el vector U */
        primerPunto(x, y) {
          this.obtieneVector(this.U, x, y);
        }

        /* Obtiene el Cuaternion de U y V */
        segundoPunto(x, y) {
          let q = new Cuaternion();

          /* Obtiene el vector V */
          this.obtieneVector(this.V, x, y);

          /* Retorna el cuaternión equivalente a la rotación. */
          if (q != null) {
            /* Calcula la Normal = U x V */
            let Normal = this.U.producto_vectorial(this.V);

            /* Calcula la longitud de la normal */
            if (Normal.longitud() > this.Epsilon) {
              /* si no es cero */
              q.x = Normal.x;
              q.y = Normal.y;
              q.z = Normal.z;
              /* w  = (theta / 2), donde theta es el ángulo de rotación */
              q.w = this.U.producto_escalar(this.V);
            } else {
              /* si es cero */
              /* U y V coinciden */
              q.x = q.y = q.z = q.w = 0.0;
            }
          }
          return q;
        }
      }

      /***************************************************************************/
      /* Cuaternion: Realiza las operaciones de los cuaterniones.                */
      /***************************************************************************/

      class Cuaternion {
        /**
         * Construye un nuevo Cuaternion.
         */
        constructor(w = 1, x = 0, y = 0, z = 0) {
          this.w = w;
          this.x = x;
          this.y = y;
          this.z = z;
        }

        inicializa(w, v) {
          this.w = w;
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
        }

        // norma^2 = w^2 + x^2 + y^2 + z^2
        norma2() {
          return (
            this.w * this.w +
            this.x * this.x +
            this.y * this.y +
            this.z * this.z
          );
        }

        // Conjugado
        conjugado() {
          x = -this.x;
          y = -this.y;
          z = -this.z;
          return this;
        }

        // Cuaternion q = Cuaternion a . Cuaternion b
        multiplica(a, b) {
          let q = new Cuaternion(0, 0, 0, 0);
          q.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
          q.x = a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y;
          q.y = a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x;
          q.z = a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w;
          return q;
        }

        // Cuaternion q = Cuaternion a . b
        multiplica_escalar(a, b) {
          let q = new Cuaternion(0, 0, 0, 0);
          q.w = a.w * b;
          q.x = a.x * b;
          q.y = a.y * b;
          q.z = a.z * b;
          return q;
        }

        // q' = q . p . q^(-1)
        rota(q, p) {
          // q es Cuaternion y p es Vector3
          let p_homogeneo = new Cuaternion(0, 0, 0, 0);
          p_homogeneo.inicializa(0, p);
          let p_prima = this.multiplica(
            q,
            this.multiplica(p_homogeneo, q.inverso())
          );
          return new Vector3(p_prima.x, p_prima.y, p_prima.z);
        }

        // q' = q . p . q*
        rota1(q, p) {
          // q es Cuaternion y p es Vector3
          let p_homogeneo = new Cuaternion(0, 0, 0, 0);
          p_homogeneo.inicializa(0, p);
          let p_prima = this.multiplica(
            q,
            this.multiplica(p_homogeneo, q.conjugado())
          );
          return new Vector3(p_prima.x, p_prima.y, p_prima.z);
        }

        // q = q^(-1)
        inverso() {
          let q = new Cuaternion(0, 0, 0, 0);
          // normal^2 = a . b
          let n = this.norma2();
          if (n <= 1e-8) document.write("INVERSO: Error");
          q = multiplica_escalar(
            new Cuaternion(this.w, -this.x, -this.y, -this.z),
            1 / n
          );
          return q;
        }

        /* Convierte el cuaternión a una matriz de rotación */
        static rota2(a, q) {
          let d, s;
          d = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;
          s = d > 0.0 ? 2.0 / d : 0.0;
          a[0] = 1.0 - (q.y * q.y + q.z * q.z) * s;
          a[4] = (q.x * q.y - q.w * q.z) * s;
          a[8] = (q.x * q.z + q.w * q.y) * s;
          a[12] = 0;
          a[1] = (q.x * q.y + q.w * q.z) * s;
          a[5] = 1.0 - (q.x * q.x + q.z * q.z) * s;
          a[9] = (q.y * q.z - q.w * q.x) * s;
          a[13] = 0;
          a[2] = (q.x * q.z - q.w * q.y) * s;
          a[6] = (q.y * q.z + q.w * q.x) * s;
          a[10] = 1.0 - (q.x * q.x + q.y * q.y) * s;
          a[14] = 0;
          a[3] = 0;
          a[7] = 0;
          a[11] = 0;
          a[15] = 1;
        }

        toString() {
          return (
            "Cuaternion [w=" +
            this.w +
            ", x=" +
            this.x +
            ", y=" +
            this.y +
            ", z=" +
            this.z +
            "]"
          );
        }
      }

      /***********************************************************************************/
      /* Se define la geometría y se almacenan en los buffers de memoria y se renderiza. */
      /***********************************************************************************/
      class Cubo {
        constructor(gl) {
          /**
           *       3 --------- 2
           *       /|        /|
           *      / |       / |
           *    7 --------- 6 |
           *     |  |      |  |
           *     | 0 ------|-- 1
           *     | /       | /
           *     |/        |/
           *    4 --------- 5
           */

          /* Las coordenadas cartesianas (x, y, z) */
          var vertices = [
            // Frente
            -1,
            -1,
            1, // 4   0
            1,
            -1,
            1, // 5   1
            1,
            1,
            1, // 6   2
            -1,
            1,
            1, // 7   3
            // Atrás
            -1,
            1,
            -1, // 3   4
            1,
            1,
            -1, // 2   5
            1,
            -1,
            -1, // 1   6
            -1,
            -1,
            -1, // 0   7
            // Izquierda
            -1,
            -1,
            -1, // 0   8
            -1,
            -1,
            1, // 4   9
            -1,
            1,
            1, // 7  10
            -1,
            1,
            -1, // 3  11
            // Derecha
            1,
            -1,
            1, // 5  12
            1,
            -1,
            -1, // 1  13
            1,
            1,
            -1, // 2  14
            1,
            1,
            1, // 6  15
            // Abajo
            -1,
            -1,
            -1, // 0  16
            1,
            -1,
            -1, // 1  17
            1,
            -1,
            1, // 5  18
            -1,
            -1,
            1, // 4  19
            // Arriba
            -1,
            1,
            1, // 7  20
            1,
            1,
            1, // 6  21
            1,
            1,
            -1, // 2  22
            -1,
            1,
            -1, // 3  23
          ];

          /* Los colores x c/vértice (r,g,b,a) */
          var colores = [
            // Frente - lila
            1,
            0,
            1,
            1, // 4   0
            1,
            0,
            1,
            1, // 5   1
            1,
            0,
            1,
            1, // 6   2
            1,
            0,
            1,
            1, // 7   3
            // Atrás - amarillo
            1,
            1,
            0,
            1, // 3   4
            1,
            1,
            0,
            1, // 2   5
            1,
            1,
            0,
            1, // 1   6
            1,
            1,
            0,
            1, // 0   7
            // Izquierda - celeste
            0,
            1,
            1,
            1, // 0   8
            0,
            1,
            1,
            1, // 4   9
            0,
            1,
            1,
            1, // 7  10
            0,
            1,
            1,
            1, // 3  11
            // Derecha - rojo
            1,
            0,
            0,
            1, // 5  12
            1,
            0,
            0,
            1, // 1  13
            1,
            0,
            0,
            1, // 2  14
            1,
            0,
            0,
            1, // 6  15
            // Abajo - azul
            0,
            0,
            1,
            1, // 0  16
            0,
            0,
            1,
            1, // 1  17
            0,
            0,
            1,
            1, // 5  18
            0,
            0,
            1,
            1, // 4  19
            // Arriba - verde
            0,
            1,
            0,
            1, // 7  20
            0,
            1,
            0,
            1, // 6  21
            0,
            1,
            0,
            1, // 2  22
            0,
            1,
            0,
            1, // 3  23
          ];

          /* Indices */
          var indices = [
            0,
            1,
            2,
            0,
            2,
            3, // Frente
            4,
            5,
            6,
            4,
            6,
            7, // Atrás
            8,
            9,
            10,
            8,
            10,
            11, // Izquierda
            12,
            13,
            14,
            12,
            14,
            15, // Derecha
            16,
            17,
            18,
            16,
            18,
            19, // Abajo
            20,
            21,
            22,
            20,
            22,
            23, // Arriba
          ];

          this.cuboVAO = gl.createVertexArray();
          gl.bindVertexArray(this.cuboVAO);

          var codigoVertices = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
          gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(vertices),
            gl.STATIC_DRAW
          );
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

          var codigoColores = gl.createBuffer();
          this.coloresBuffer = codigoColores;
          gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
          gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(colores),
            gl.STATIC_DRAW
          );
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

          var codigoDeIndices = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
          gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indices),
            gl.STATIC_DRAW
          );

          gl.bindVertexArray(null);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }

        dibuja(gl) {
          gl.bindVertexArray(this.cuboVAO);
          gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
          gl.bindVertexArray(null);
        }
      }

      class Cilindro {
        constructor(
          gl,
          radio,
          alto,
          sectores,
          colorRGBA,
          capTop = true,
          capBottom = true
        ) {
          this.gl = gl;
          this.sectores = sectores;
          const posiciones = [];

          // Vertices laterales (2 por sector: inferior y superior)
          for (let i = 0; i <= sectores; i++) {
            const theta = (i / sectores) * 2 * Math.PI;
            const x = radio * Math.cos(theta);
            const z = radio * Math.sin(theta);
            posiciones.push(x, -alto / 2, z);
            posiciones.push(x, alto / 2, z);
          }

          // Opcional: centro de tapa superior
          let idxCentroTop = -1;
          if (capTop) {
            idxCentroTop = posiciones.length / 3;
            posiciones.push(0, alto / 2, 0);
          }

          // Opcional: centro de tapa inferior
          let idxCentroBot = -1;
          if (capBottom) {
            idxCentroBot = posiciones.length / 3;
            posiciones.push(0, -alto / 2, 0);
          }

          // Construir índices
          const indices = [];
          // Caras laterales
          for (let i = 0; i < sectores; i++) {
            const base = i * 2;
            const next = base + 2;
            // Triángulos de la cara
            indices.push(base, next, next + 1);
            indices.push(base, next + 1, base + 1);
          }
          // Tapa superior
          if (capTop) {
            for (let i = 0; i < sectores; i++) {
              const topVert = i * 2 + 1;
              const nextTop = ((i + 1) * 2 + 1) % ((sectores + 1) * 2);
              indices.push(idxCentroTop, topVert, nextTop);
            }
          }
          // Tapa inferior
          if (capBottom) {
            for (let i = 0; i < sectores; i++) {
              const botVert = i * 2;
              const nextBot = ((i + 1) * 2) % ((sectores + 1) * 2);
              indices.push(idxCentroBot, nextBot, botVert);
            }
          }

          this.indexCount = indices.length;

          // Crear VAO
          this.vao = gl.createVertexArray();
          gl.bindVertexArray(this.vao);

          // Buffer de posiciones
          const posBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
          gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(posiciones),
            gl.STATIC_DRAW
          );
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

          // Buffer de colores (un color uniforme)
          const totalVerts = posiciones.length / 3;
          const colores = new Float32Array(totalVerts * 4);
          for (let i = 0; i < totalVerts; i++) {
            colores.set(colorRGBA, i * 4);
          }
          this.coloresBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, this.coloresBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, colores, gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

          // Buffer de índices
          const idxBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
          gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indices),
            gl.STATIC_DRAW
          );

          // Desactivar VAO
          gl.bindVertexArray(null);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }

        dibuja(gl) {
          gl.bindVertexArray(this.vao);
          gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
          gl.bindVertexArray(null);
        }
      }
      class Esfera {
        constructor(gl, radio, stacks, slices, colorRGBA) {
          const posiciones = [];
          const indices = [];
          // Generar vértices
          for (let stack = 0; stack <= stacks; stack++) {
            const phi = (Math.PI * stack) / stacks; // de 0 a PI
            const y = radio * Math.cos(phi);
            const r = radio * Math.sin(phi);
            for (let slice = 0; slice <= slices; slice++) {
              const theta = (2 * Math.PI * slice) / slices; // de 0 a 2PI
              const x = r * Math.cos(theta);
              const z = r * Math.sin(theta);
              posiciones.push(x, y, z);
            }
          }
          // Triangulación: quad entre stacks y slices
          for (let stack = 0; stack < stacks; stack++) {
            for (let slice = 0; slice < slices; slice++) {
              const first = stack * (slices + 1) + slice;
              const second = first + (slices + 1);
              indices.push(first, second, first + 1);
              indices.push(second, second + 1, first + 1);
            }
          }
          this.indexCount = indices.length;
          // Crear VAO
          this.vao = gl.createVertexArray();
          gl.bindVertexArray(this.vao);
          // Buffer posiciones
          const posBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
          gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(posiciones),
            gl.STATIC_DRAW
          );
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
          // Buffer colores uniforme
          const totalVerts = posiciones.length / 3;
          const colores = new Float32Array(totalVerts * 4);
          for (let i = 0; i < totalVerts; i++) colores.set(colorRGBA, i * 4);
          const colorBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, colores, gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
          // Buffer índices
          const idxBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
          gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indices),
            gl.STATIC_DRAW
          );
          // Desactivar VAO
          gl.bindVertexArray(null);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }

        dibuja(gl) {
          gl.bindVertexArray(this.vao);
          gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
          gl.bindVertexArray(null);
        }
      }
      class Edificio {
        constructor(gl, pisos, color1, color2) {
          this.pisos = pisos;
          this.color1 = color1;
          this.color2 = color2;
          this.cubo = new Cubo(gl);
        }
        dibuja(gl) {
          for (let i = 0; i < this.pisos; i++) {
            const c = i % 2 === 0 ? this.color1 : this.color2;
            const coloresPiso = new Float32Array(24 * 4);
            for (let v = 0; v < 24; v++) {
              coloresPiso[v * 4 + 0] = c[0];
              coloresPiso[v * 4 + 1] = c[1];
              coloresPiso[v * 4 + 2] = c[2];
              coloresPiso[v * 4 + 3] = c[3];
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, this.cubo.coloresBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, coloresPiso);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            let m = MatrizModelo.slice();
            traslacion(m, 0, i - 0.5, 0);
            escalacion(m, 2, 0.5, 2);
            gl.uniformMatrix4fv(uMatrizModelo, false, m);
            this.cubo.dibuja(gl);
          }
        }
      }
      class Arbol {
        constructor(gl) {
          const radioTronco = 0.5,
            altoTronco = 2,
            sectTronco = 16;
          const cT = [0.55, 0.27, 0.07, 1];
          this.tronco = new Cilindro(
            gl,
            radioTronco,
            altoTronco,
            sectTronco,
            cT,
            false,
            false
          );

          // Genera un verde aleatorio
          const minG = 0.2,
            maxG = 1.0;
          const g = Math.random() * (maxG - minG) + minG;
          const cH = [0, g, 0, 1];

          const radioHoja = 1.2;
          const stacks = 16; // subdivisiones verticales
          const slices = 32; // subdivisiones horizontales

          this.hoja = new Esfera(gl, radioHoja, stacks, slices, cH);
        }

        dibuja(gl) {
          // ── Tronco ──
          let mT = MatrizModelo.slice();
          traslacion(mT, 0, 1, 0);
          escalacion(mT, 1, 2, 1);
          gl.uniformMatrix4fv(uMatrizModelo, false, mT);
          this.tronco.dibuja(gl);

          // ── Copa ──
          let mH = MatrizModelo.slice();
          traslacion(mH, 0, 4, 0);
          escalacion(mH, 2, 2, 2);
          gl.uniformMatrix4fv(uMatrizModelo, false, mH);
          this.hoja.dibuja(gl);
        }
      }

      /***************************************************************************/
      /* Eventos del Ratón                                                       */
      /***************************************************************************/

      function mouseDown(event) {
        var posx = new Number();
        var posy = new Number();

        /* Obtiene la coordenada dentro de la área mayor */
        if (event.x != undefined && event.y != undefined) {
          posx = event.x;
          posy = event.y;
        } else {
          posx =
            event.clientX +
            document.body.scrollLeft +
            document.documentElement.scrollLeft;
          posy =
            event.clientY +
            document.body.scrollTop +
            document.documentElement.scrollTop;
        }

        /* Obtiene la coordenada dentro del canvas */
        posx = posx - canvas.offsetLeft;
        posy = posy - canvas.offsetTop;

        /* Matriz = MatrizRotacion */
        Matriz = MatrizRotacion.slice(); /* Copia */
        arcBall.primerPunto(posx, posy);

        boton_izq_presionado = true;

        return false;
      }

      function mouseUp(e) {
        boton_izq_presionado = false;
      }

      function mouseMove(event) {
        if (!boton_izq_presionado) return false;

        var posx = new Number();
        var posy = new Number();

        /* Obtiene la coordenada dentro de la área mayor */
        if (event.x != undefined && event.y != undefined) {
          posx = event.x;
          posy = event.y;
        } else {
          posx =
            event.clientX +
            document.body.scrollLeft +
            document.documentElement.scrollLeft;
          posy =
            event.clientY +
            document.body.scrollTop +
            document.documentElement.scrollTop;
        }

        /* Obtiene la coordenada dentro del canvas */
        posx = posx - canvas.offsetLeft;
        posy = posy - canvas.offsetTop;

        /* Actualiza el segundo vector y obtiene el cuaternión */
        let q = arcBall.segundoPunto(posx, posy);

        /* Convierte el cuaternión a una matriz de rotación */
        Cuaternion.rota2(MatrizRotacion, q);

        /* MatrizRotacion = MatrizRotacion * Matriz */
        multiplica(MatrizRotacion, MatrizRotacion, Matriz);
      }
      function dibuja() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // 1) Vista animada sin mutar MatrizVista base
        gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);

        // 2) Piso principal
        let modeloBase = MatrizRotacion.slice();
        traslacion(modeloBase, 0, -2, 0);
        escalacion(modeloBase, 25, 1, 25);
        gl.uniformMatrix4fv(uMatrizModelo, false, modeloBase);
        // — actualiza color y dibuja cubo —
        const negro = new Float32Array(24 * 4);
        for (let v = 0; v < 24; v++) {
          negro[v * 4 + 0] = 0.2;
          negro[v * 4 + 1] = 0.4;
          negro[v * 4 + 2] = 0.2;
          negro[v * 4 + 3] = 1.0;
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, cubo.coloresBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, negro);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        cubo.dibuja(gl);

        // 3) Segundo piso
        let suelo = MatrizRotacion.slice();
        traslacion(suelo, 0, -1.9, 0);
        escalacion(suelo, 25, 1, 3);
        gl.uniformMatrix4fv(uMatrizModelo, false, suelo);
        const color2 = new Float32Array(24 * 4);
        for (let v = 0; v < 24; v++) {
          color2[v * 4 + 0] = 0.1;
          color2[v * 4 + 1] = 0.1;
          color2[v * 4 + 2] = 0.1;
          color2[v * 4 + 3] = 1.0;
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, cubo.coloresBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, color2);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        cubo.dibuja(gl);

        // 4) Edificios y árboles
        let s = 0;
        edificios.forEach((ed, idx) => {
          s++;
          // 1) Genera la matriz de modelo para este edificio
          let mObj = MatrizRotacion.slice();
          traslacion(mObj, -12 + idx * 8, 0, s % 2 ? -6 : 6);

          // 2) Copia esa matriz en la global MatrizModelo
          for (let i = 0; i < 16; i++) {
            MatrizModelo[i] = mObj[i];
          }

          // 3) Ahora ed.dibuja() usará esa MatrizModelo para posicionar y escalar
          ed.dibuja(gl);
        });
        arboles.forEach((ar, idx) => {
          s++;
          let mObj = MatrizRotacion.slice();
          traslacion(mObj, -12 + idx * 8, 0, s % 2 ? 6 : -6);

          for (let i = 0; i < 16; i++) {
            MatrizModelo[i] = mObj[i];
          }

          ar.dibuja(gl);
        });

        requestAnimationFrame(dibuja);
      }

      function reinicia() {
        /* Matriz de Rotación */
        identidad(MatrizRotacion);

        dibuja();
      }

      function main() {
        canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl2");
        if (!gl) {
          document.write("WebGL 2.0 no está disponible en tu navegador");
          return;
        }

        /* Para detectar los eventos del ratón */
        canvas.addEventListener("mousedown", mouseDown, false);
        canvas.addEventListener("mouseup", mouseUp, false);
        canvas.addEventListener("mouseout", mouseUp, false);
        canvas.addEventListener("mousemove", mouseMove, false);

        /* Para los botones */
        document.getElementById("reset").onclick = reinicia;

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        compilaEnlazaLosShaders();

        cubo = new Cubo(gl);
        edificios = [];
        for (let i = 0; i < 4; i++) {
          edificios.push(
            new Edificio(
              gl,
              Math.random() * (12 - 8) + 8,
              [0.2 * Math.random(), 0.8 * Math.random(), 0.8, 1], // color claro
              [0.2, 0.2, 0.2, 1] // color oscuro
            )
          );
        }
        arboles = [];
        for (let i = 0; i < 4; i++) {
          arboles.push(new Arbol(gl));
        }

        arcBall = new ArcBall(canvas.width, canvas.height);

        gl.useProgram(programaID);
        uMatrizProyeccion = gl.getUniformLocation(
          programaID,
          "uMatrizProyeccion"
        );
        uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
        uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
        identidad(MatrizVista);
        perspective(
          MatrizProyeccion,
          45,
          canvas.width / canvas.height,
          0.1,
          100
        );
        gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

        identidad(MatrizVista);
        traslacion(MatrizVista, 0, -2, -35);
        rotacionX(MatrizVista, 35); // levanta la cámara
        rotacionY(MatrizVista, -15); // levanta la cámara

        gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
        /* Ajusta el ancho a [-1..1] y el alto a [-1..1] */
        arcBall.ajusta(gl.canvas.width, gl.canvas.height);

        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(1, 1, 0.5, 1.0);
        // inicializa la rotación antes de dibujar
        identidad(MatrizRotacion);
        // llama a reinicia() para que haga la primera draw con MatrizRotacion = identidad
        reinicia();
      }
      window.onload = main;
    </script>
  </body>
</html>
